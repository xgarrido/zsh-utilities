#+TITLE:  Zsh Utilities Functions
#+AUTHOR: Xavier Garrido
#+DATE:   2013-02-08
#+OPTIONS: toc:nil num:nil ^:nil

This is part of the [[file:zsh-utilities.org][Zsh Utilities]].

* Zsh Utilities - Functions
This file provides several functions for very different use. See the description
to understand the aim of each of them.

** Package manager
This part defines some function in relation with package management. It defines
generic function name given the linux system installed : "debian-like" system or
[[https://www.archlinux.org/][archlinux]].

*** Check linux system
#+BEGIN_SRC sh
  function __is_debian ()
  {
      if pkgtools__has_binary apt-fast; then
          __pkg_mgr="apt-fast"
          return 0
      elif pkgtools__has_binary apt-get; then
          __pkg_mgr="apt-get"
          return 0
      elif pkgtools__has_binary yaourt; then
          __pkg_mgr="yaourt"
          return 1
      elif pkgtools__has_binary pacman; then
          __pkg_mgr="pacman"
          return 1
      fi
  }
#+END_SRC
*** Implement generic function
#+BEGIN_SRC sh
  alias pkg-notify='notify -t 2000 -i stock_dialog-info "${__pkg_mgr}"'
  if __is_debian; then

      function install ()
      {
          __pkgtools__at_function_enter install
          sudo ${__pkg_mgr} install -y $* && pkg-notify "Installed $@"
          __pkgtools__at_function_exit
          return 0
      }
      compdef "_deb_packages uninstalled" install

      function remove ()
      {
          __pkgtools__at_function_enter remove
          sudo ${__pkg_mgr} remove -y $* && pkg-notify "Removed $@"
          __pkgtools__at_function_exit
          return 0
      }
      compdef "_deb_packages installed" remove

      function upgrade ()
      {
          __pkgtools__at_function_enter upgrade
          sudo ${__pkg_mgr} update && sudo ${__pkg_mgr} upgrade && pkg-notify "Upgrade done"
          __pkgtools__at_function_exit
          return 0
      }

      function search ()
      {
          __pkgtools__at_function_enter search
          apt-cache search $@
          __pkgtools__at_function_exit
          return 0
      }

      function purge ()
      {
          __pkgtools__at_function_enter purge
          sudo ${__pkg_mgr} purge && pkg-notify "Purge done"
          __pkgtools__at_function_exit
          return 0
      }

      function distupgrade ()
      {
          __pkgtools__at_function_enter distupgrade
          sudo ${__pkg_mgr} update && sudo ${__pkg_mgr} dist-upgrade && pkg-notify "Distribution upgrade done"
          __pkgtools__at_function_exit
          return 0
      }

      function autoremove ()
      {
          __pkgtools__at_function_enter autoremove
          sudo ${__pkg_mgr} autoremove && pkg-notify "Autoremove done"
          __pkgtools__at_function_exit
          return 0
      }
  else
      function upgrade ()
      {
          __pkgtools__at_function_enter upgrade
          ${__pkg_mgr} -Suy && pkg-notify "Upgrade done"
          __pkgtools__at_function_exit
          return 0
      }

      function upgrade-devel ()
      {
          __pkgtools__at_function_enter upgrade-devel
          ${__pkg_mgr} -Suya --devel && pkg-notify "Upgrade done"
          __pkgtools__at_function_exit
          return 0
      }

      function search ()
      {
          __pkgtools__at_function_enter search
          ${__pkg_mgr} -Ss $@
          __pkgtools__at_function_exit
          return 0
      }

      function purge ()
      {
          __pkgtools__at_function_enter purge
          ${__pkg_mgr} -Qdt && pkg-notify "Purge done"
          __pkgtools__at_function_exit
          return 0
      }
  fi
#+END_SRC

** Extract archive
#+BEGIN_SRC sh
  function extract ()
  {
      __pkgtools__at_function_enter extract
      local remove_archive
      local success
      local file_name
      local extract_dir

      if [[ "$1" == "" ]]; then
          echo "Usage: extract [-option] [file ...]"
          echo
          echo "Options:"
          echo "    -r, --remove : Remove archive."
          echo
      fi

      remove_archive=1
      if [[ "$1" == "-r" ]] || [[ "$1" == "--remove" ]]; then
          remove_archive=0
          shift
      fi

      while [ -n "$1" ]; do
          if [[ ! -f "$1" ]]; then
              pkgtools__msg_warning "'$1' is not a valid file"
              shift
              continue
          fi

          success=0
          file_name="$( basename "$1" )"
          extract_dir="$( echo "$file_name" | sed "s/\.${1##*.}//g" )"
          case "$1" in
              (*.tar.gz|*.tgz) tar xvzf "$1" ;;
              (*.tar.bz2|*.tbz|*.tbz2) tar xvjf "$1" ;;
              (*.tar.xz|*.txz) tar --xz --help &> /dev/null \
                  && tar --xz -xvf "$1" \
                  || xzcat "$1" | tar xvf - ;;
              (*.tar.zma|*.tlz) tar --lzma --help &> /dev/null \
                  && tar --lzma -xvf "$1" \
                  || lzcat "$1" | tar xvf - ;;
              (*.tar) tar xvf "$1" ;;
              (*.gz) gunzip "$1" ;;
              (*.bz2) bunzip2 "$1" ;;
              (*.xz) unxz "$1" ;;
              (*.lzma) unlzma "$1" ;;
              (*.Z) uncompress "$1" ;;
              (*.zip) unzip "$1" -d $extract_dir ;;
              (*.rar) unrar e -ad "$1" ;;
              (*.7z) 7za x "$1" ;;
              (*.deb)
                  mkdir -p "$extract_dir/control"
                  mkdir -p "$extract_dir/data"
                  cd "$extract_dir"; ar vx "../${1}" > /dev/null
                  cd control; tar xzvf ../control.tar.gz
                  cd ../data; tar xzvf ../data.tar.gz
                  cd ..; rm *.tar.gz debian-binary
                  cd ..
                  ;;
              (*)
                  pkgtools__msg_error "'$1' cannot be extracted" 1>&2
                  success=1
                  ;;
          esac

          (( success = $success > 0 ? $success : $? ))
          (( $success == 0 )) && (( $remove_archive == 0 )) && rm "$1"
          shift
      done
      __pkgtools__at_function_exit
      return 0
  }
#+END_SRC

** Notification
Base function for notification
#+BEGIN_SRC sh
  function notify ()
  {
      if pkgtools__has_binary notify-send; then
          if [ "$HOSTNAME" = "garrido-laptop" ]; then
              notify-send $@ > /dev/null 2>&1
          fi
      fi
      return 0
  }
#+END_SRC
*** Success
#+BEGIN_SRC sh
  function notify_success ()
  {
      __pkgtools__at_function_enter notify_success
      if [ $? -ne 0 ]; then
          notify -t 2000 -i stock_dialog-info "Notice" "${PREEXEC_CMD:-Shell Command}"
      fi
      __pkgtools__at_function_exit
      return 0
  }
#+END_SRC
*** Error
#+BEGIN_SRC sh
  function notify_error ()
  {
      if [ $? -ne 0 ]; then
          notify -t 2000 -i stock_dialog-error " " "${PREEXEC_CMD:-Shell Command} $@"
          return 1
      fi
      return 0
  }
#+END_SRC
*** Warning
#+BEGIN_SRC sh
  function notify_warning ()
  {
      notify -t 3000 -i stock_dialog-warning " " "${PREEXEC_CMD:-Shell Command} $@"
      return 0
  }
#+END_SRC

** Zsh =precmd= and =preexec=
These two functions are only available for =zsh= shell. There are run at every
shell command and trigger notification events in case of long time command or
failling ones. This is pretty useful when long command such as compilation
command are running : user can go to another desktop do whatever he wants but
get warned when the command has finished or has failed.
#+BEGIN_SRC sh
  function precmd ()
  {
      # must be first
      notify_error

      # BEGIN notify long running cmds
      stop=$(date +'%s')
      start=${PREEXEC_TIME:-$stop}
      let elapsed=$stop-$start
      max=${PREEXEC_MAX:-10}

      for i in ${PREEXEC_EXCLUDE_LIST:-}; do
          if [ "x$i" = "x$PREEXEC_CMD" ]; then
              max=999999;
              break;
          fi
      done

      if [ $elapsed -gt $max ]; then
          notify_warning "finished ($elapsed secs)"
      fi
      # END notify long running cmds

      # Update scheme color
      if (( $+functions[__load_scheme] )); then
          __load_scheme
      fi

      return 0
  }

  function preexec ()
  {
      if [[ "$TERM" == "screen" ]]; then
          local CMD=${1}
          echo -ne "\ek$CMD\e\\"
      fi
      # for notifying of long running commands
      export PREEXEC_CMD=`echo $1 | awk '{ print $1; }'`
      export PREEXEC_TIME=$(date +'%s')
      return 0
  }
#+END_SRC

** SSH connection
This should be improved by doing something as wakeonlan did with a small machine
db.

#+BEGIN_SRC sh
  function connect ()
  {
      __pkgtools__at_function_enter connect
      local use_screen=0
      local server_name=
      local ssh_option=
      local append_command=

      if [[ "$1" == "" ]]; then
          echo "Missing the name of machine to connect !"
          echo ""
          __pkgtools__at_function_exit
          return 1
      fi

      while [ -n "$1" ]; do
          if [[ "$1" == "-s" ]]; then
              use_screen=1
          elif [[ "$1" == "fzk" ]]; then
              ssh_option="-p 24"
              server_name="augerlogin.fzk.de"
          elif [[ "$1" == "cern" ]]; then
              server_name="xgarrido@lxplus.cern.ch"
          elif [[ "$1" == "lyon" ]]; then
              server_name="garrido@ccage.in2p3.fr"
          elif [[ $1 == ccige* ]]; then
              server_name="garrido@$1.in2p3.fr"
          elif [[ $1 == ccage* ]]; then
              server_name="garrido@$1.in2p3.fr"
          elif [[ "$1" == "ovh" ]]; then
              ssh_option="-p 1234"
              server_name="garrido@r17187.ovh.net"
          elif [[ "$1" == "laptop" ]]; then
              server_name="garrido@nb-nemo6.lal.in2p3.fr"
          elif [[ "$1" == "mac" ]]; then
              ssh_option="-p 24"
              server_name="garrido@xgarrido.dyndns.org"
          elif [[ "$1" == "syno" ]]; then
              server_name="garrido@xgarrido.ydns.eu"
          # elif [[ "$1" == "debian" ]]; then
          #     server_name="debian@xgarrido.dyndns.org"
          elif [[ "$1" == "lx3" ]]; then
              server_name="garrido@lx3.lal.in2p3.fr"
          elif [[ "$1" == "daq-nemo" ]]; then
              server_name="bipolal@pc-nemo12.lal.in2p3.fr"
          elif [[ "$1" == "daq-lsm" ]]; then
              server_name="nemoacq@lsmlx5.in2p3.fr"
          elif [[ $1 == pc-nemo* ]]; then
              server_name="nemo@$1"
          elif [[ $1 == pc-91089 ]]; then
              server_name="garrido@$1"
          elif [[ $1 == nemo* ]]; then
              server_name="garrido@$1.lal.in2p3.fr"
          # else
          #     if [ "${HOSTNAME}" = "garrido-laptop" ]; then
          #         server_name="garrido@localhost"
          #         if [ -f /tmp/npu.d/ports ]; then
          #             ssh_port=$(cat /tmp/npu.d/ports | grep $1 | cut -d' ' -f2)
          #             ssh_option="-p ${ssh_port}"
          #         else
          #             append_command+="$1 "
          #         fi
          #     else
          #         if [[ "$1" == "pc" ]]; then
          #             server_name="pc-91089.lal.in2p3.fr"
          #         else
          #             server_name="$1.lal.in2p3.fr"
          #         fi
          #     fi
          fi
          shift 1
      done

      if [ ${use_screen} -eq 0 ]; then
          pkgtools__msg_notice "Connecting to ${server_name}..."
          ssh -Y ${ssh_option} ${server_name} "${append_command}"
      else
          pkgtools__msg_notice "Connecting to ${server_name} with screen support..."
          screen ssh -Y ${ssh_option} ${server_name}
      fi

      __pkgtools__at_function_exit
      return 0
  }
  # Connect completion system
  compdef _connect connect

  function _connect ()
  {
      local -a _machines
      _machines=(
          ccage:'CC Lyon job machines'
          ccige:'CC Lyon interactive machines'
          laptop:'Laptop machine'
          mac:'iMac machine'
          syno:'Synology server @ home'
          lx3:'lxplus machine @ LAL'
          nemo3:'nemo3 machine @ LAL'
          nemo4:'nemo4 machine @ LAL'
          pc-91089:'PC server machine @ LAL'
          pc-nemo4:'V. Treytak machine'
          pc-nemo5:'H. Gomez machine'
          pc-nemo6:'Student machine'
          pc-nemo8:'G. Eurin machine'
      )
      _describe -t _machines 'SSH machines' _machines && ret=0
  }
#+END_SRC

** Grepping information
*** Find a running job
#+BEGIN_SRC sh
  function psgrep ()
  {
      __pkgtools__at_function_enter psgrep
      if [[ ! -z $1 ]] ; then
          pkgtools__msg_notice "Grepping for processes matching $1..."
          ps aux | grep $1 | grep -v grep
      else
          pkgtools__msg_error "Need name to grep for !"
          __pkgtools__at_function_exit
          return 1
      fi
      __pkgtools__at_function_exit
      return 0
  }
#+END_SRC

*** Find a command within history
#+BEGIN_SRC sh
  function hgrep ()
  {
      __pkgtools__at_function_enter hgrep
      if [[ ! -z $1 ]] ; then
          pkgtools__msg_notice "Grepping for command matching $1..."
          history | grep $1
      else
          pkgtools__msg_error "Need name to grep for !"
          __pkgtools__at_function_exit
          return 1
      fi
      __pkgtools__at_function_exit
      return 0
  }
#+END_SRC

** Text edition
*** Remove all trailing whitespace in a given file
#+BEGIN_SRC sh
  function remove_trailing_whitespace ()
  {
      __pkgtools__at_function_enter remove_trailing_whitespace
      if [[ ! -z $1 ]] ; then
          pkgtools__msg_notice "Removing trailing whitespace in file $1..."
          find $1 -type f -exec sed -i 's/ *$//' '{}' ';'
      else
          pkgtools__msg_error "Missing filename !"
          __pkgtools__at_function_exit
          return 1
      fi
      __pkgtools__at_function_exit
      return 0
  }
#+END_SRC
*** Remove duplicate lines
#+BEGIN_SRC sh
  function remove_duplicate_lines ()
  {
      __pkgtools__at_function_enter remove_duplicate_lines
      if [[ ! -z $1 ]] ; then
          pkgtools__msg_notice "Removing duplicate lines in file $1..."
          awk '!seen[$0]++' $1 > /tmp/$(basename $1).tmp
          mv /tmp/$(basename $1).tmp $1
      else
          pkgtools__msg_error "Missing filename !"
          __pkgtools__at_function_exit
          return 1
      fi
      __pkgtools__at_function_exit
      return 0
  }
#+END_SRC
** Image edition
*** Convert an EPS figure into tikz
#+BEGIN_SRC sh
  function eps2tikz ()
  {
      __pkgtools__at_function_enter eps2tikz
      local use_helvetica=0
      local keep_xfig=0
      local eps_file=
      local parse_switch=1

      if [[ "$1" == "" ]]; then
          echo "Usage: eps2tikz [-option] [eps files ...]"
          echo
          echo "Options:"
          echo "    -k, --keep-xfig : Keep the intermediate xfig file."
          echo
      fi

      while [ -n "$1" ]; do
          token="$1"
          if [[ "${token[1]}" = "-" ]]; then
              opt=${token}
              if [[ ${parse_switch} -eq 0 ]]; then
                  break
              fi
              if [ "${opt}" = "--keep-xfig" ]; then
                  keep_xfig=1
              else
                  pkgtools__msg_warning "Ignoring option '${opt}' !"
              fi
          else
              arg=${token}
              parse_switch=0
              if [ "${arg##*.}" = "eps" ]; then
                  eps_file="${eps_file} ${arg}"
              else
                  pkgtools_msg_warning "'${eps_file}' is not an Encapsulated PostScript"
              fi
          fi
          shift
      done

      if [[ -z "${eps_file}" ]]; then
          pkgtools__msg_error "Missing EPS file !"
          __pkgtools__at_function_exit
          return 1
      fi

      for i in $(echo ${eps_file}); do
          if [ ! -f "${i}" ]; then
              pkgtools__msg_warning "File ${i} does not exist! Skip it"
              continue
          fi

          local fig_file=${i/.eps/.fig}
          local tikz_file=${i/.eps/.tikz}

          pkgtools__msg_notice "Converting ${i} file to ${tikz_file}..."

          if [[ ! -x $(which pstoedit) ]]; then
              pkgtools__msg_error "Missing 'pstoedit' binary !"
              __pkgtools__at_function_exit
              return 1
          fi
          pstoedit -f xfig "${i}" > ${fig_file} 2> /dev/null

          if [[ ! -x $(which fig2tikz) ]]; then
              pkgtools__msg_error "Missing fig2tikz' binary !"
              __pkgtools__at_function_exit
              return 1
          fi
          fig2tikz ${fig_file} > ${tikz_file}.tmp
          pkgtools__msg_notice "Remove duplicate lines..."
          awk '!seen[$0]++' ${tikz_file}.tmp > ${tikz_file}
          rm -f ${tikz_file}.tmp

          if [[ ${keep_xfig} -eq 0 ]]; then
              rm -f ${fig_file}
          fi

      done
      __pkgtools__at_function_exit
      return 0
  }
#+END_SRC

*** Grab point with =dexter=
[[http://sourceforge.net/projects/dexter/][Dexter]] is a little java program to interactively or semi-automatically extract
data from scanned graphs. In its applet incarnation it is used by the
Astrophysics Data System.

#+BEGIN_SRC sh
  function dexter ()
  {
      __pkgtools__at_function_enter dexter
      if [[ "$1" == "" ]]; then
          echo "Usage: dexter [image files ...]"
          echo
          __pkgtools__at_function_exit
          return 1
      else
          java -jar /home/garrido/Workdir/Development/java/dexter/Debuxter.jar $1
      fi
      __pkgtools__at_function_exit
      return 0
  }
#+END_SRC

** Mounting/unmounting USB drives
#+BEGIN_SRC sh
  function usb_umount ()
  {
      for d in /media/*; do
          sudo umount $d
      done
      sudo modprobe usb_storage
  }
#+END_SRC
** Subversion functions
*** Better SVN status
#+BEGIN_SRC sh
  function svnstatus ()
  {
      __pkgtools__at_function_enter svnstatus
      templist=$(svn status $*)
      echo "$(echo $templist | grep '^?' | wc -l) unversioned files/directories"
      echo $templist | grep -v '^?'
      __pkgtools__at_function_exit
      return 0
  }
#+END_SRC
*** Better SVN diff (needs code2color)
#+BEGIN_SRC sh
  function svndiff ()
  {
      __pkgtools__at_function_enter svndiff
      svn diff $* | code2color -l patch -
      __pkgtools__at_function_exit
      return 0
  }
#+END_SRC
** Misc.
*** Grabbing video from mms link
#+BEGIN_SRC sh
  function grab_video ()
  {
      __pkgtools__at_function_enter grab_video
      if [[ ! -z $1 ]] ; then
          pkgtools__msg_notice "Grabing video from $1 link and saving it to /tmp/dump_video.avi..."
          mplayer -dumpstream "$1" -dumpfile /tmp/dump_video.avi
      else
          pkgtools__msg_error "Missing mms link !"
          __pkgtools__at_function_exit
          return 1
      fi
      __pkgtools__at_function_exit
      return 0
  }
#+END_SRC

#+TITLE:  Zsh Utilities Work
#+AUTHOR: Xavier Garrido
#+DATE:   2013-02-08
#+OPTIONS: toc:nil num:nil ^:nil

This is part of the [[file:zsh-utilities.org][Zsh Utilities]].

* Zsh Utilities - Work
This file contains some function/alias in relation with "work" topic.
** pkgtools aliases                                               :obsolete:
=pkgtools= is used as wrapper for installation. It is a bash program which wraps
=cmake= or some =Makefile= and is intensively used with SuperNEMO software.
#+BEGIN_SRC sh :tangle no
  alias pkg-notify='notify -t 2000 -i stock_dialog-info "pkgtools"'

  function pkgc ()
  {
      ./pkgtools.d/pkgtool configure $@ && pkg-notify "Configure done"
  }

  function pkgb ()
  {
      ./pkgtools.d/pkgtool build && pkg-notify "Build done"
  }

  function pkgt ()
  {
      ./pkgtools.d/pkgtool test && pkg-notify "Running test programs done"
  }

  function pkgr ()
  {
      ./pkgtools.d/pkgtool reset && pkg-notify "Reset done"
  }

  function pkgi ()
  {
      ./pkgtools.d/pkgtool install && pkg-notify "Install done"
  }
#+END_SRC

** ROOT aliases & functions
#+BEGIN_SRC sh
  alias root='root -l'
#+END_SRC

*** Initialize with a =TBrowser=
#+BEGIN_SRC sh
  function root/newBrowser () {
      local file_list=
      while [ -n "$1" ]; do
          file="$1"
          if [ ! -f $file ]; then
              pkgtools__msg_error "Could not find file $file"
          else
              file_list+="$file "
          fi
          shift 1
      done
      root -l $(echo ${file_list}) ~/.config/root/macros/newBrowser.C
      return 0;
  }
  alias rb="root/newBrowser"
#+END_SRC
*** Merge =TTree=
#+BEGIN_SRC sh
function root/mergeTree () {
}
#+END_SRC
** SN@ilWare setup
*** =Bayeux/Falaise= wrappers
**** Private wrappers
#+BEGIN_SRC sh
  function --flvisualize ()
  {
      if (( $+commands[colout] )); then
          $(pkgtools__get_binary_path flvisualize) $@ 2>&1 | colout -t mylogging -T ${zsh_utilities_dir}
      else
          $(pkgtools__get_binary_path flvisualize) $@
      fi
  }
  function --bxdpp_processing ()
  {
      mkdir -p /tmp/garrido/snemo.d
      if (( $+commands[colout] )); then
          TIMEFMT="$terminfo[bold]$fg[blue][notice]:${reset_color}$fg[blue] %U user %S system %P cpu %*E total";\
              time $(pkgtools__get_binary_path bxdpp_processing) $@ 2>&1 | \
              colout -t mylogging -T ${zsh_utilities_dir} | \
              colout "([0-9]+) (pro.*:)(.*\))(.*\))" blue,blue,green,red bold,normal,bold,bold
      else
          time $(pkgtools__get_binary_path bxdpp_processing) $@
      fi
  }
  function --bxocd_manual ()
  {
      if (( $+commands[cm] )); then
          $(pkgtools__get_binary_path bxocd_manual) $@ | colout -t mylogging -T ${zsh_utilities_dir} | colout -s rst
      else
          $(pkgtools__get_binary_path bxocd_manual) $@
      fi
  }
#+END_SRC
**** =mydpp_processing=
***** Wrapper arround =bxdpp_processing=
#+BEGIN_SRC sh
  function mydpp_processing ()
  {
      __pkgtools__at_function_enter mydpp_processing
      if ! $(pkgtools__has_binary bxdpp_processing); then
          pkgtools__msg_error "SN@ilWare has not been set"
          __pkgtools__at_function_exit
          return 1
      fi
      local opt=
      while [ -n "$1" ]; do
          token="$1"
          case "$token" in
              --*-generator)
                  shift 1
                  local parameter=${token:2}
                  opt+="--variant-set=simulation:${parameter//-/_}_name=$1 "
                  ;;
              --source-material)
                  shift 1
                  opt+="--variant-set=detector:bb_source_material=snemo::$1 "
                  ;;
              --Bz-magnitude)
                  shift 1
                  opt+="--variant-set=detector:Bz_magnitude=$1 "
                  ;;
              --magnetic-field-type)
                  shift 1
                  opt+="--variant-set=detector:magnetic_field_type=$1 "
                  ;;
              --*-energy-resolution | --*-*-energy-threshold)
                  shift 1
                  local parameter=${token:2}
                  opt+="--variant-set=detector:${parameter//-/_}=$1 "
                  ;;
              --random-seeds)
                  opt+="--variant-set=simulation:random_seed_flag=true "
                  ;;
              --spg-*)
                  shift 1
                  local parameter=${token:2}
                  opt+="--variant-set=simulation:${parameter//-/_}=$1 "
                  ;;
              --output-path)
                  shift 1
                  if [ ! -d $1 ]; then
                      mkdir -p $1
                  fi
                  opt+="--variant-set=core:output_path=$1 "
                  ;;
              --dev-logging)
                  shift 1
                  opt+="--variant-set=core:logging_priority=$1 "
                  ;;
              *)
                  opt+="$token "
                  ;;
          esac
          shift 1
      done
      _dump () {
          local prefix="[notice]:"
          declare -A db
          local variants=( $(echo ${opt} | tr " " "\n" | grep 'variant-set') )
          for i in ${variants}; do
              local registry=$(echo $i | awk -F'[=:]' '{print $2}')
              local parameter=$(echo $i | awk -F'[=:]' '{print $3}')
              local value=$(echo $i | awk -F'[=:]' '{print $4}')
              db[$registry]+="$prefix â†³ Parameter '$parameter': $value\n"
          done
          echo
          if [ ! -n "${variants}" ]; then
              echo "$prefix Variants set to their default values !"
          else
              echo "$prefix Variants dump:"
          fi

          for k in "${(@k)db}"; do
              echo "$prefix Registry '$k'"
              for i in ${db[$k]}; do
                  echo "$i"
              done
          done
      }
      local _config=$SNAILWARE_SIMULATION_DIR/snemo_simulation_configuration/current
      local _flressource=$(flquery --resourcedir | tr -d '\n')
      local _bxdll=$(bxquery --libdir | tr -d '\n')
      local _fldll=$(flquery --libdir | tr -d '\n')
      --bxdpp_processing                                         \
          --module-manager-config ${_config}/module_manager.conf \
          --dlls-config ${_config}/dlls.conf                     \
          --variant-config ${_config}/snvariant_manager.conf     \
          --datatools::resource-path=bxdll@${_bxdll}             \
          --datatools::resource-path=fldll@${_fldll}             \
          --datatools::resource-path=falaise@${_flressource}     \
          --datatools::resource-path=configuration@${_config}    \
          $(echo ${opt})
      if (( $+commands[colout] )); then
          _dump | colout -t mylogging -T ${zsh_utilities_dir}
      fi
      unset _config _snware _falaise
      __pkgtools__at_function_exit
      return 0
  }
#+END_SRC

***** Completion function
#+BEGIN_SRC shell
  compdef _mydpp_processing mydpp_processing
  function _mydpp_processing ()
  {
      _config=$SNAILWARE_SIMULATION_DIR/snemo_simulation_configuration/current
      _module_all () {
          # we cache the list of repository
          if (( ! $+modulelist )); then
              if [ ! -z "$_config" ]; then
                  for f in $(eval echo ${_config})/*.conf; do
                      line=$(cat $f | grep "\[.*type=.*_module.*\]")
                      name=$(echo $line | sed 's@\[name="\(.*\)".*type.*@\1@')
                      modulelist+=( $(echo $name) )
                  done
              fi
          fi
      }
      _arguments                                                                                              \
          {-P,--logging-priority}'[set logging priority]:logging:->log'                                       \
          {-l,--load-dll}'[set a DLL to be loaded]'                                                           \
          {-L,--dlls-config}'[set the DLL loader configuration file]:file:_files -g \*.conf'                  \
          {-%,--modulo}'[set the modulo print period for data record]:number'                                 \
          {-M,--max-records}'[set the maximum number of data records to be processed]:number'                 \
          {-X,--no-max-records}'[Do not limit the maximum number of data records to be processed]:number'     \
          {-m,--module}'[add a module in the pipeline (optional)]:module:->module'                            \
          {-c,--module-manager-config}'[set the module manager configuration file]:manager:_files -g \*.conf' \
          {-i,--input-file}'[set an input file (optional)]:file:_files -g    \*.{brio,xml,data.gz,txt}'       \
          {-o,--output-file}'[set the output file (optional)]:file:_files -g \*.{brio,xml,data.gz,txt}'       \
          {-O,--max-records-per-output-file}'[set the maximum number of data records per output file]:number' \
          '--event-generator[set event generator]:eg:->eg'                                                    \
          '--vertex-generator[set vertex generator]:vg:->vg'                                                  \
          '--magnetic-field-type[set the magnetic field type]:mft:->mft'                                      \
          '--Bz-magnitude[set Bz magnetic field magnitude]'                                                   \
          '--calo-energy-resolution[set main wall energy resolution]'                                         \
          '--xcalo-energy-resolution[set X-wall energy resolution]'                                           \
          '--gveto-energy-resolution[set gamma veto energy resolution]'                                       \
          '--calo-high-energy-threshold[set main wall high energy threshold]'                                 \
          '--xcalo-high-energy-threshold[set X-wall high energy threshold]'                                   \
          '--gveto-high-energy-threshold[set gamma veto high energy threshold]'                               \
          '--calo-low-energy-threshold[set main wall low energy threshold]'                                   \
          '--xcalo-low-energy-threshold[set X-wall low energy threshold]'                                     \
          '--gveto-low-energy-threshold[set gamma low veto energy threshold]'                                 \
          '--spg-name[set particle name for single particle generator (spg)]:spgname:->spgname'               \
          '--spg-monokinetic-energy[set the monokinetic energy for single particle generator (spg)]'          \
          '--spg-flat-energy-min[set the minimal energy for single particle generator (spg)]'                 \
          '--spg-flat-energy-max[set the maximal energy for single particle generator (spg)]'                 \
          '--spg-gaussian-energy-mean[set the mean energy for single particle generator (spg)]'               \
          '--spg-gaussian-energy-sigma[set the sigma energy for single particle generator (spg)]'             \
          '--random-seeds[set all seeds to random values]'                                                    \
          '--source-material[set the source foil material]:bbsm:->bbsm'                                       \
          '--output-path[set the output directory of generated files]:file:_files'                            \
          '--dev-logging[set the development logging priority]:logging:->log'                                 \
          '--datatools\:\:variant-set=core\:[Set the values of a variant]:vs:->vs'                            \
          '*: :->args'                                                                                        \
          && ret=0
      case $state in
          module)
              _module_all
              _describe -t modulelist 'module' modulelist && ret=0
              ;;
          args)
              _path_files -/ && ret=0
              ;;
          log)
              _logs=(
                  "fatal"
                  "critical"
                  "error"
                  "warning"
                  "notice"
                  "information"
                  "debug"
                  "trace"
              )
              _values 'Logging priority' $_logs && ret=0
              ;;
          mft)
              _mfts=(
                  "Bz_uniform"
                  "Bz_polynomial"
                  "B_mapped"
              )
              _values 'Magnetic field type' $_mfts && ret=0
              ;;
          eg)
              _egs=( $(sed -n '/event_generator_name/, /^\[/ { /string.enumerated_/ p }' \
                           ${_config}/simulation_variants.def | awk -F \" '{print $2}') )
              _values 'Event generator' $_egs && ret=0
              ;;
          spgname)
              _spgs=( $(sed -n '/spg_name/, /^\[/ { /string.enumerated_/ p }' \
                            ${_config}/simulation_variants.def | awk -F \" '{print $2}') )
              _values 'Single particle generator name' $_spgs && ret=0
              ;;
          vg)
              _vgs=( $(sed -n '/vertex_generator_name/, /^\[/ { /string.enumerated_/ p }' \
                           ${_config}/simulation_variants.def | awk -F \" '{print $2}') )
              _values 'Vertex generator' $_vgs && ret=0
              ;;
          bbsm)
              _bbsms=( $(sed -n '/bb_source_material/, /^\[/ { /string.enumerated_/ p }' \
                             ${_config}/detector_variants.def | awk -F \" '{print substr($2,8)}' ) )
              _values 'Source materials' $_bbsms && ret=0
              ;;
          vs)
              _vss=( $(sed -n '/parameters\./ { s/....$//p }' \
                           ${_config}/*_variants.def | awk -F \" '{print $2}') )
              _values 'Parameters' $_vss && ret=0
              ;;
      esac
      return ret
  }
#+END_SRC

**** =mydpp_analysis=
***** Wrapper arround =bxdpp_processing=
#+BEGIN_SRC sh
  function mydpp_analysis ()
  {
      __pkgtools__at_function_enter mydpp_analysis
      if $(pkgtools__has_binary bxdpp_processing); then
          opt=
          while [ -n "$1" ]; do
              token="$1"
          #     if [ "${token}" = "--event-generator" -o "${token}" = "-e" ]; then
          #         shift 1
          #         opt+="--datatools::variant-set=simulation:event_generator_name=$1 "
          #     else
              opt+="$token "
          #     fi
            shift 1
          done
          _config=$SNAILWARE_SIMULATION_DIR/snemo_analysis_modules/config
          --bxdpp_processing                                              \
              --module-manager-config ${_config}/module_manager.conf      \
              --dlls-config ${_config}/dlls.conf                          \
              --datatools::resource-path=falaise@$(flquery --resourcedir | tr -d '\n') \
              $(echo ${opt})
              # --datatools::variant-config=${_config}/snvariant_manager.conf                                                     \
              # --datatools::resource-path=snware@$SNAILWARE_PRO_DIR                                                              \
              # --datatools::resource-path=configuration@${_config}                                                               \
      else
          pkgtools__msg_error "SN@ilWare has not been set"
          __pkgtools__at_function_exit
          return 1
      fi

      __pkgtools__at_function_exit
      return 0
  }
#+END_SRC

***** Completion function
#+BEGIN_SRC shell
  compdef _mydpp_analysis mydpp_analysis
  function _mydpp_analysis ()
  {
      _config=$SNAILWARE_SIMULATION_DIR/snemo_analysis_modules/config
      _module_all () {
          # we cache the list of repository
          if (( ! $+ana_modulelist )); then
              if [ ! -z "$_config" ]; then
                  for f in $(eval echo ${_config})/*.conf; do
                      line=$(cat $f | grep "\[.*type=.*_module.*\]")
                      name=$(echo $line | sed 's@\[name="\(.*\)".*type.*@\1@')
                      ana_modulelist+=( $(echo $name) )
                  done
              fi
          fi
      }
      _arguments                                                                                              \
          {-P,--logging-priority}'[set logging priority]:logging:->log'                                       \
          {-l,--load-dll}'[set a DLL to be loaded]'                                                           \
          {-L,--dlls-config}'[set the DLL loader configuration file]:file:_files -g \*.conf'                  \
          {-%,--modulo}'[set the modulo print period for data record]:number'                                 \
          {-M,--max-records}'[set the maximum number of data records to be processed]:number'                 \
          {-X,--no-max-records}'[Do not limit the maximum number of data records to be processed]:number'     \
          {-m,--module}'[add a module in the pipeline (optional)]:module:->module'                            \
          {-c,--module-manager-config}'[set the module manager configuration file]:manager:_files -g \*.conf' \
          {-i,--input-file}'[set an input file (optional)]:file:_files -g    \*.{brio,xml,data.gz,txt}'       \
          {-o,--output-file}'[set the output file (optional)]:file:_files -g \*.{brio,xml,data.gz,txt}'       \
          '*: :->args'                                                                                        \
          && ret=0
      case $state in
          log)
              _logs=(
                  "fatal"
                  "critical"
                  "error"
                  "warning"
                  "notice"
                  "information"
                  "debug"
                  "trace"
              )
              _values 'Logging priority' $_logs && ret=0
              ;;
          module)
              _module_all
              _describe -t ana_modulelist 'module' ana_modulelist && ret=0
              ;;
          args)
              _path_files -/ && ret=0
              ;;
      esac
      return ret
  }
#+END_SRC

**** =myocd_manual=
***** Wrapper arround =bxocd_manual=
#+BEGIN_SRC sh
  function myocd_manual ()
  {
      __pkgtools__at_function_enter myocd_manual
      if $(pkgtools__has_binary bxocd_manual); then
          _lib_dir=$SNAILWARE_PRO_DIR/falaise/install/lib64
          _libs=$(find ${_lib_dir} -type f -name "*.so")
          libs=
          for l in ${=_libs}; do
              libs+=$(echo -n "--load-dll $(echo $l | sed 's/.*lib\(.*\)\.so/\1/')@$(dirname $l) ")
          done
          --bxocd_manual $(echo $libs) $@
      else
          pkgtools__msg_error "SN@ilWare has not been set"
          __pkgtools__at_function_exit
          return 1
      fi

      __pkgtools__at_function_exit
      return 0
  }
#+END_SRC

***** Completion function
#+BEGIN_SRC shell
  compdef _myocd_manual myocd_manual
  function _myocd_manual ()
  {
      _ocd_all () {
          # we cache the list of repository
          if (( ! $+ocdlist )); then
              ocdlist+=( $(myocd_manual --action list | tail -n +2 | sed 's/:/\\:/g') )
          fi
      }
      _arguments                                                                             \
          {-P,--logging-priority}'[set logging priority]:logging:->log'                      \
          {-l,--load-dll}'[set a DLL to be loaded]'                                          \
          {-L,--dlls-config}'[set the DLL loader configuration file]:file:_files -g \*.conf' \
          {-c,--class-id}'[set the ID of the class to be investigated]:class:->class'        \
          {-a,--action}'[define the action to be performed]:action:->action'                 \
          {-i,--input-file}'[set an input file (optional)]:file:_files'                      \
          {-o,--output-file}'[set the output file (optional)]:file:_files'                   \
          '*: :->args'                                                                       \
          && ret=0
      case $state in
          log)
              _logs=(
                  "fatal"
                  "critical"
                  "error"
                  "warning"
                  "notice"
                  "information"
                  "debug"
                  "trace"
              )
              _values 'Logging priority' $_logs && ret=0
              ;;
          action)
              _actions=(
                  "list"
                  "show"
                  "skeleton"
                  "validate"
              )
              _values 'Action list' $_actions && ret=0
              ;;
          class)
              _ocd_all
              _describe -t ocdlist 'OCD' ocdlist && ret=0
              ;;
          args)
              #_path_files -/ && ret=0
              ;;
      esac
  return ret
  }
#+END_SRC

**** =myvisualize=
***** Wrapper arround =flvisualize=
#+BEGIN_SRC sh
  function myvisualize ()
  {
    __pkgtools__at_function_enter myvisualize
    _config=$SNAILWARE_SIMULATION_DIR/snemo_simulation_configuration/current
    --flvisualize $@
    # --datatools::resource-path=configuration@${_config} \
    # $@
    __pkgtools__at_function_exit
    return 0
  }
#+END_SRC
***** Completion function
#+BEGIN_SRC shell
  compdef _flvisualize myvisualize
#+END_SRC
**** Other completion system
#+BEGIN_SRC sh
  compdef _genbb_inspector bxgenbb_inspector
#+END_SRC

*** =brew= setup
#+BEGIN_SRC sh
  function set_brew ()
  {
      pkgtools__msg_notice "Setting brew installation"
      pkgtools__add_path_to_PATH ~/Workdir/NEMO/supernemo/snware/brew/cadfaelbrew/bin
  }
  function unset_brew ()
  {
      pkgtools__msg_notice "Unsetting brew installation"
      pkgtools__remove_path_to_PATH ~/Workdir/NEMO/supernemo/snware/brew/cadfaelbrew/bin
  }
#+END_SRC
** Lyon ccali setup
*** Preamble
#+BEGIN_SRC sh
  if [[ $HOSTNAME = cc* ]]; then
#+END_SRC

*** =qsub= aliases
#+BEGIN_SRC sh
  alias qjob_my_total='echo -ne "Total number of jobs: ";qstat | tail -n+3 | wc -l'
  alias qjob_my_run='echo -ne "Number of running jobs: ";qstat -s r | tail -n+3 | wc -l'
#+END_SRC
*** SuperNEMO configuration
#+BEGIN_SRC sh
  function do_nemo_setup()
  {
      alias qjob_nemo_user='echo "Number of jobs run by NEMO users"; qstat -u \* -ext -s r| tail -n+3 | grep nemo | awk "{print \$5}" | sort | uniq -c'
      alias qjob_summary='qjob_my_total; qjob_my_run; qjob_nemo_user'

      # Use up-to-date gcc
      local gcc_version=5.2.0
      local gcc_dir=/usr/local/gcc/${gcc_version}
      pkgtools__add_path_to_PATH  ${gcc_dir}/bin
      pkgtools__add_path_to_LD_LIBRARY_PATH ${gcc_dir}/lib64

      # Set brew cache directory (default ~/.cache)
      pkgtools__reset_variable HOMEBREW_CACHE ${SCRATCH_DIR}/workdir/supernemo/software/brew/.cache
      # pkgtools__reset_variable HOMEBREW_TEMP ${SCRATCH_DIR}/workdir/supernemo/snware/brew/.tmp
      pkgtools__reset_variable HOMEBREW_MAKE_JOBS 4
      pkgtools__reset_variable HOMEBREW_CC gcc-${gcc_version:0:1}
      pkgtools__reset_variable HOMEBREW_CXX g++-${gcc_version:0:1}
  }
#+END_SRC
*** CMB configuration
**** Preamble
#+BEGIN_SRC sh
  function do_cmb_setup()
  {
#+END_SRC
**** Aliases
#+BEGIN_SRC  sh
  alias qjob_planck_user='echo "Number of jobs run by Planck users"; qstat -u \* -ext -s r| tail -n+3 | grep planck | awk "{print \$5}" | sort | uniq -c'
  alias qjob_summary='qjob_my_total; qjob_my_run; qjob_planck_user'
#+END_SRC
**** Environment variables
#+BEGIN_SRC sh
  # Unset to start from fresh config.
  pkgtools__unset_variable LD_LIBRARY_PATH
  pkgtools__unset_variable PATH

  # bin directories
  pkgtools__add_path_to_PATH /bin
  pkgtools__add_path_to_PATH /usr/bin

  # Unset planck PYHTONHOME
  unset PYTHONHOME
  unset CFLAGS

  # Set pip cache directory
  mkdir -p /tmp/garrido.d
  pkgtools__reset_variable PIP_DOWNLOAD_CACHE /tmp/garrido.d

  # MKL
  local intel_compiler_library=/usr/local/intel/compilers_and_libraries_2017/linux
  pkgtools__add_path_to_PATH ${intel_compiler_library}/bin/intel64
  pkgtools__add_path_to_LD_LIBRARY_PATH ${intel_compiler_library}/lib/intel64
  pkgtools__reset_variable MKLROOT ${intel_compiler_library}/mkl
  pkgtools__add_path_to_LD_LIBRARY_PATH $MKLROOT/lib/intel64
#+END_SRC
**** Run MCMC jobs
***** Wrapper
#+BEGIN_SRC sh
  function run_cmb_mcmc()
  {
      __pkgtools__default_values
      __pkgtools__at_function_enter run_cmb_mcmc

      if [[ ${PKGMAN_SETUP_DONE} != cmb ]]; then
          pkgtools__msg_error "CMB configuration not setup!"
          __pkgtools__at_function_exit
          return 1
      fi

      local mcmc=$CAMELROOT/$CMTCONFIG/mcmc
      local parfile
      local nsamples=500000
      local nchain=4
      local ncore=8
      local queue=mc_long
      local project=P_planck
      while [ -n "$1" ]; do
          local token="$1"
          if [ ${token[0,1]} = - ]; then
              local opt=${token}
              if [[ ${opt} = -h || ${opt} = --help ]]; then
                  echo "Usage:\n run_cmb_mcmc [options] parfile"
                  echo "Options:"
                  echo " -h [--help]  print this help message"
                  echo " -d [--debug] debug mode"
                  echo " -D [--devel] devel mode"
                  echo " --nsamples   set number of MCMC samples"
                  echo " --nchain     set number of qjob chains"
                  echo " --ncore      set number of qjob cores"
                  return 0
              elif [[ ${opt} = -d || ${opt} = --debug ]]; then
                  pkgtools__msg_using_debug
              elif [[ ${opt} = -D || ${opt} = --devel ]]; then
                  pkgtools__msg_using_devel
              elif [[ ${opt} = --nsamples ]]; then
                  shift 1
                  nsamples="$1"
              elif [[ ${opt} = --nchain ]]; then
                  shift 1
                  nchain="$1"
              elif [[ ${opt} = --ncore ]]; then
                  shift 1
                  ncore="$1"
              fi
          else
              parfile="${token}"
          fi
          shift 1
      done

      if [ -z ${parfile} ]; then
          pkgtools__msg_error "Missing parameter file!"
          __pkgtools__at_function_exit
          return 1
      elif [ ! -f ${parfile} ]; then
          pkgtools__msg_error "Parameter file '${parfile}' does not exist!"
          __pkgtools__at_function_exit
          return 1
      fi
      # Make sure PWD is added
      local parfile_dir=$(dirname ${parfile})
      if [[ ${parfile_dir} = . ]]; then
          parfile_dir=$PWD
          parfile=$PWD/${parfile}
      fi
      local parfile_base=$(basename ${parfile})
      local parfile_name=${parfile_base%.*}

      # Get total number of MCMC parameters
      local ndim=$(awk '$1=="par"{n++} END{print n}' ${parfile})
      pkgtools__msg_notice "Number of parameters : ${ndim}"

      # Get covariance file
      local covfile=${parfile/.par/.cov}
      if [ ! -f ${covfile} ]; then
          pkgtools__msg_error "Missing associated covariance file!"
          __pkgtools__at_function_exit
          return 1
      fi

      # Create output directory
      local mcmc_dir=${parfile_dir}/${parfile_name}_MC
      if [ -d ${mcmc_dir} ]; then
          pkgtools__msg_warning "Directory '${mcmc_dir}' already exist!"
          pkgtools__yesno_question "Do you want to remove it ?"
          if $(pkgtools__answer_is_no); then
              __pkgtools__at_function_exit
              return 0
          fi
          rm -rf ${mcmc_dir}
      fi
      mkdir -p ${mcmc_dir}
      pkgtools__enter_directory ${mcmc_dir}

      # Setup MCMC
      cp ${covfile} .
      # Remove precision from parfile
      grep -v precision ${parfile} > ${parfile_base}
      {
          echo "dim=$ndim"
          echo "algo=ada"
          echo "length=$nsamples"
          echo "proposal_cov=$PWD/$(basename ${covfile})"
          echo "ts=10000"
          echo "t0=2000"
          echo "scale=0.001"
          echo "do_move=false"
      } >> ${parfile_base}

      # Create job script
      {
          echo "#$ -l sps=1"
          echo "#$ -l os=sl6"
          echo "#$ -j y"
          echo "#$ -R y"
          echo "#$ -t 1-$nchain"
          echo "#$ -N ${parfile_name}"
          # echo "#$ -m be"
          echo
          echo "echo \"running on : \$(uname -a)\""
          echo "source $(dirname $(which python))/activate"
          echo "export OMP_NUM_THREADS=$ncore"
          echo "cd \$TMPDIR"
          echo "cp ${mcmc} ."
          echo "cp $PWD/${parfile_base} mcmc\${SGE_TASK_ID}.par"
          echo "cp $PWD/${parfile_base/.par/.cov} ."
          echo "echo \"seed=\$RANDOM\" >> mcmc\${SGE_TASK_ID}.par"
          echo
          echo "cp mcmc\${SGE_TASK_ID}.par $PWD"
          echo
          echo "./mcmc mcmc\${SGE_TASK_ID}.par $PWD/samples\${SGE_TASK_ID}.txt > $PWD/output\${SGE_TASK_ID}.log 2>&1"
          echo
          echo "cp ar_vs_length.txt $PWD/ar_vs_length\${SGE_TASK_ID}.txt"
          echo "cp scale_vs_length.txt $PWD/scale_vs_length\${SGE_TASK_ID}.txt"
          echo "cp corr.txt $PWD/corr\${SGE_TASK_ID}.txt"
          echo
          echo "qstat -j \${JOB_ID} -nenv"
      } >> ${parfile_name}.sh

      pkgtools__msg_notice "Parameter file  : ${parfile}"
      pkgtools__msg_notice "Covariance file : ${covfile}"
      pkgtools__msg_notice "MCMC directory  : ${mcmc_dir}"
      pkgtools__msg_notice "CC jobs setup :"
      pkgtools__msg_notice " - Number of chains : ${nchain}"
      pkgtools__msg_notice " - Number of cores  : ${ncore}"
      pkgtools__msg_notice " - Queue type       : ${queue}"
      pkgtools__msg_notice " - Project type     : ${project}"
      pkgtools__yesno_question "Start jobs ?"
      if $(pkgtools__answer_is_yes); then
          qsub -P ${project} -pe multicores ${ncore} -q ${queue} -o $PWD ${parfile_name}.sh
      fi

      pkgtools__exit_directory
      __pkgtools__at_function_exit
      return 0
  }
#+END_SRC
***** Completion
#+BEGIN_SRC sh
  compdef _run_cmb_mcmc run_cmb_mcmc
  function _run_cmb_mcmc ()
  {
      _arguments                                   \
          {-h,--help}'[print this help message]'   \
          {-d,--debug}'[debug mode]'               \
          {-D,--devel}'[devel mode]'               \
          '--nsamples[set number of MCMC samples]' \
          '--nchain[set number of qjob chains]'    \
          '--ncore[set number of qjob cores]'      \
          '*:file:_files -g \*.par'                \
          && ret=0

      return ret
  }
#+END_SRC
**** Postamble
#+BEGIN_SRC sh
  }
#+END_SRC
*** Postamble
#+BEGIN_SRC sh
  fi
#+END_SRC

** Activate g++ warnings
#+BEGIN_SRC sh
  function activate_cxxflags ()
  {
      __pkgtools__at_function_enter activate_cxxflags
      export CXXFLAGS="-Waddress -Warray-bounds -Wc++11-compat -Wchar-subscripts      \
    -Wenum-compare -Wcomment -Wformat -Wmain -Wmaybe-uninitialized -Wmissing-braces \
    -Wnonnull -Wparentheses -Wreorder -Wreturn-type -Wsequence-point -Wsign-compare \
    -Wstrict-aliasing -Wstrict-overflow=1 -Wswitch -Wtrigraphs -Wuninitialized      \
    -Wunknown-pragmas -Wunused-function -Wunused-label -Wunused-value               \
    -Wunused-variable -Wvolatile-register-var -Wclobbered -Wempty-body              \
    -Wignored-qualifiers -Wmissing-field-initializers -Wsign-compare -Wtype-limits  \
    -Wuninitialized -Wunused-parameter -Wunused-but-set-parameter"
      __pkgtools__at_function_exit
      return 0
  }
#+END_SRC
** Generate org doc skeletons
*** Main function
**** Parsing options
#+BEGIN_SRC sh
  function make_org_doc ()
  {
      __pkgtools__default_values
      __pkgtools__at_function_enter make_org_doc

      # Internal functions
      --mod::usage () {
      }

      local append_list_of_options
      local append_list_of_arguments

      local type
      local title
      local author="Xavier Garrido"
      local email="xavier.garrido@lal.in2p3.fr"
      local latex_class
      local latex_class_options
      local base_directory
      while [ -n "$1" ]; do
          local token=$1
          if [ "${token[0,1]}" = "-" ]; then
              local opt=${token}
              append_list_of_options+="${opt} "
              if [ "${opt}" = "-h" -o "${opt}" = "--help" ]; then
                  --mod::usage
                  return 0
              elif [ "${opt}" = "-d" -o "${opt}" = "--debug" ]; then
                  pkgtools__msg_using_debug
              elif [ "${opt}" = "-D" -o "${opt}" = "--devel" ]; then
                  pkgtools__msg_using_devel
              elif [ "${opt}" = "-v" -o "${opt}" = "--verbose" ]; then
                  pkgtools__msg_using_verbose
              elif [ "${opt}" = "-W" -o "${opt}" = "--no-warning" ]; then
                  pkgtools__msg_not_using_warning
              elif [ "${opt}" = "-q" -o "${opt}" = "--quiet" ]; then
                  pkgtools__msg_using_quiet
                  export PKGTOOLS_MSG_QUIET=1
              elif [ "${opt}" = "-i" -o "${opt}" = "--interactive" ]; then
                  pkgtools__ui_interactive
              elif [ "${opt}" = "-b" -o "${opt}" = "--batch" ]; then
                  pkgtools__ui_batch
              elif [ "${opt}" = "--gui" ]; then
                  pkgtools__ui_using_gui
              elif [ "${opt}" = "--doc-type" ]; then
                  shift 1; type="$1"
              elif [ "${opt}" = "--title" ]; then
                  shift 1; title="$1"
              elif [ "${opt}" = "--author" ]; then
                  shift 1; author="$1"
              elif [ "${opt}" = "--email" ]; then
                  shift 1; email="$1"
              elif [ "${opt}" = "--latex-class" ]; then
                  shift 1; latex_class="$1"
              elif [ "${opt}" = "--latex-class-options" ]; then
                  shift 1; latex_class_options="$1"
              elif [ "${opt}" = "--base-directory" ]; then
                  shift 1; base_directory="$1"
              fi
          else
              arg=${token}
              if [ "x${arg}" != "x" ]; then
                  append_list_of_arguments+="${arg} "
              fi
          fi
          shift 1
      done
#+END_SRC
**** Parsing options
#+BEGIN_SRC sh
  local dirname="$(echo ${append_list_of_arguments} | awk '{print $1}')"
  if [ "${dirname}" = "" ]; then
      pkgtools__msg_error "You must give a repository name !"
      __pkgtools__at_function_exit
      return 1
  fi

  if [ ! -n "$type" ]; then
      pkgtools__msg_error "Missing type of documents !"
      __pkgtools__at_function_exit
      return 1
  fi

  case $type in
      (talk)
          test ! -n "$base_directory" && base_directory=~/Workdir/Talk
          test ! -n "$latex_class" && latex_class="beamer"
          test ! -n "$latex_class_options" && latex_class_options="snemo,nologo"
          ;;
      (note)
          ;;
      (article)
          test ! -n "$base_directory" && base_directory=~/Workdir/Papers/pub/nemo-note
          test ! -n "$latex_class" && latex_class="snemo-article"
          test ! -n "$latex_class_options" && latex_class_options=""
          ;;
  esac

  pkgtools__msg_devel "base_directory=${base_directory}"
  pkgtools__msg_devel "latex_class=${latex_class}"
  pkgtools__msg_devel "latex_class_options=${latex_class_options}"

  # Remove last space
  append_list_of_arguments=${append_list_of_arguments%?}
  append_list_of_options=${append_list_of_options%?}
  pkgtools__msg_devel "append_list_of_arguments=${append_list_of_arguments}"
  pkgtools__msg_devel "append_list_of_options=${append_list_of_options}"
#+END_SRC
**** Internal functions
***** Create directories
#+BEGIN_SRC sh
  local directory=${base_directory}/${dirname}
  --mod::create_directories () {
      mkdir -p ${directory}/{pdf,figures}
  }
#+END_SRC
***** Generate org skeleton
#+BEGIN_SRC sh
  --mod::generate_org_skeleton () {
      local org_file
      case $type in
          (talk)
              org_file=${directory}/talk.org
              ;;
          (article)
              org_file=${directory}/note-$(date +%y%m%d).org
              ;;
      esac
      echo "#+TITLE:  ${title}"                               > ${org_file}
      echo "#+AUTHOR: ${author}"                             >> ${org_file}
      echo "#+EMAIL:  ${email}"                              >> ${org_file}
      echo "#+DATE:   $(date +%d/%m/%Y)"                     >> ${org_file}
      case $type in
          (talk)
              echo "#+OPTIONS: toc:nil num:nil author:nil email:t ^:{}" >> ${org_file}
              echo "#+STARTUP: beamer"                       >> ${org_file}
              ;;
          (article)
              echo "#+OPTIONS: toc:nil date:nil author:nil email:t ^:{}" >> ${org_file}
              echo "#+STARTUP: entitiespretty"               >> ${org_file}
              ;;
      esac
      echo "#+LATEX_CLASS: ${latex_class}"                   >> ${org_file}
      echo "#+LATEX_CLASS_OPTIONS: [${latex_class_options}]" >> ${org_file}
      echo ""                                                >> ${org_file}
      # Special setup for article
      case $type in
          (article)
              begin="#+BEGIN"
              end="#+END"
              echo "* Abstract :ignoreheading:" >> ${org_file}
              echo "${begin}_ABSTRACT" >> ${org_file}
              echo "${end}_ABSTRACT" >> ${org_file}
              echo "* Introduction :ignoresecnumber:" >> ${org_file}
              echo "* Conclusion :ignoresecnumber:" >> ${org_file}
              echo "* References :ignoresecnumber:" >> ${org_file}
              echo "${begin}_BIBLIOGRAPHY" >> ${org_file}
              echo "${end}_BIBLIOGRAPHY" >> ${org_file}
              ;;
      esac
  }
#+END_SRC
***** Generate =makefile=
#+BEGIN_SRC sh
  --mod::generate_makefile () {
      local make_file=${directory}/Makefile
      case $type in
          (talk)
              echo "# -*- mode: makefile; -*-"                                         > ${make_file}
              echo "EMACS=emacs"                                                      >> ${make_file}
              echo "BATCH=\$(EMACS) --batch --eval '(setq starter-kit-dir \"~/.emacs.d\")' \
                                    --load '~/.emacs.d/starter-kit-org.el'"           >> ${make_file}
              echo "files_org = \$(wildcard *.org)"                                   >> ${make_file}
              echo "files_pdf = \$(files_org:.org=.pdf)"                              >> ${make_file}
              echo                                                                    >> ${make_file}
              echo "all: \$(files_pdf)"                                               >> ${make_file}
              echo                                                                    >> ${make_file}
              echo "%.pdf: %.org"                                                     >> ${make_file}
              echo "\t@echo \"NOTICE: Exporting \$< to pdf...\";"                     >> ${make_file}
              echo "\t@\$(BATCH) --visit \"\$<\" --funcall org-beamer-export-to-pdf"  >> ${make_file}
              echo "\t@cp \$@ pdf/\${@:.pdf=_${dirname}.pdf}"                         >> ${make_file}
              echo                                                                    >> ${make_file}
              echo "tar : clean"                                                      >> ${make_file}
              echo "\t@mkdir -p tar"                                                  >> ${make_file}
              echo "\t@cd tar && tar --exclude=\"../.git*\" --exclude=\"../tar\" -czvf talk_{dirname}.tar.gz .">> ${make_file}
              echo                                                                    >> ${make_file}
              echo "clean:"                                                           >> ${make_file}
              echo "\t@rm -rf latex.d *.tex *.pdf *.fdb* *~ *.el tar"                 >> ${make_file}
              echo "\t@rm -rf *.out *.fls *.toc *.aux *.snm *.nav *.log"              >> ${make_file}
              ;;
          (article)
              echo "# -*- mode: makefile; -*-"                                    > ${make_file}
              echo "EMACS=emacs"                                                 >> ${make_file}
              echo "BATCH=\$(EMACS) --batch --eval '(setq starter-kit-dir \"~/.emacs.d\")' \
                                    --load '~/.emacs.d/starter-kit-org.el'"      >> ${make_file}
              echo "files_org  = \$(wildcard note*.org)"                         >> ${make_file}
              echo "files_pdf  = doc/pdf/\$(files_org:.org=.pdf)"                >> ${make_file}
              echo "files_html = doc/html/\$(files_org:.org=.html)"              >> ${make_file}
              echo                                                               >> ${make_file}
              echo "all: pdf"                                                    >> ${make_file}
              echo                                                               >> ${make_file}
              echo "pdf: \$(files_pdf)"                                          >> ${make_file}
              echo "doc/pdf/%.pdf: %.org"                                        >> ${make_file}
              echo "\t@echo \"NOTICE: Exporting $< to pdf...\""                  >> ${make_file}
              echo "\t@zsh -i -c \"org-pages --pdf --debug generate\""           >> ${make_file}
              echo                                                               >> ${make_file}
              echo "html: \$(files_html)"                                        >> ${make_file}
              echo "doc/html/%.html: %.org"                                      >> ${make_file}
              echo "\t@echo \"NOTICE: Exporting $< to html...\""                 >> ${make_file}
              echo "\t@zsh -i -c \"org-pages --html --debug generate\""          >> ${make_file}
              echo                                                               >> ${make_file}
              echo "clean:"                                                      >> ${make_file}
              echo "\t@rm -rf latex.d doc *.tex *.pdf *.toc *.fdb* *~ README.el" >> ${make_file}
              echo                                                               >> ${make_file}
              echo ".PHONY: all pdf html clean"                                  >> ${make_file}
              ;;
      esac
  }
#+END_SRC
***** Generate =.gitignore=
#+BEGIN_SRC sh
      --mod::generate_gitignore () {
          local gitignore=${directory}/.gitignore
          echo "/*.pdf"         >> ${gitignore}
          echo "/*.tex"         >> ${gitignore}
          echo "/*.auxlock"     >> ${gitignore}
          echo "/*.vrb"         >> ${gitignore}
          echo "/*.fdb_latexmk" >> ${gitignore}
          echo "/*.fls"         >> ${gitignore}
          echo "/*.aux"         >> ${gitignore}
          echo "*~"             >> ${gitignore}
          echo "latex.d/"       >> ${gitignore}
        }
#+END_SRC
***** Import function
#+BEGIN_SRC sh
  --mod::import_doc () {
      (
          local svn_directory
          case $type in
              (talk)
                  svn_directory=https://svn.lal.in2p3.fr/users/garrido/Talk
                  ;;
              (article)
                  svn_directory=https://svn.lal.in2p3.fr/users/garrido/Publications/nemo-note
                  ;;
          esac
          if [ -d ${directory}/.git ]; then
              pkgtools__msg_warning "Directory '${directory}' is already under git-svn !"
              return 0
          fi
          svn mkdir ${svn_directory}/${dirname} -m "create ${dirname} directory"
          svn import ${directory} ${svn_directory}/${dirname} -m "import trunk directory"
          rm -rf ${base_directory}/${dirname}
          mkdir -p ${base_directory}/${dirname}
          cd ${base_directory}/${dirname}
          git svn init --prefix=svn/ --trunk=. ${svn_directory}/${dirname}
          git svn fetch
      )
  }
#+END_SRC
**** Calling functions
#+BEGIN_SRC sh
  --mod::create_directories
  --mod::generate_org_skeleton
  --mod::generate_makefile
  --mod::generate_gitignore
  --mod::import_doc

  # Finally goto the directory
  cd ${base_directory}/${dirname}

  unset title author email latex_class latex_class_options
  unset dirname directory base svn_directory org_file
  unset append_list_of_arguments append_list_of_options
  unfunction -- --mod::usage
  unfunction -- --mod::import_doc
  unfunction -- --mod::generate_gitignore
  unfunction -- --mod::generate_makefile
  unfunction -- --mod::generate_org_skeleton
  unfunction -- --mod::create_directories
  __pkgtools__at_function_exit
  return 0
  }
#+END_SRC

*** Completion function
#+BEGIN_SRC sh
  # Connect completion system
  compdef _make_org_doc make_org_doc
  _make_org_doc () {
      _arguments -C                                                                      \
          '(-h --help)'{-h,--help}'[print help message]'                                 \
          '(-v --verbose)'{-v,--verbose}'[produce verbose logging]'                      \
          '(-d --debug)'{-d,--debug}'[produce debug logging]'                            \
          '(-D --devel)'{-D,--devel}'[produce devel logging]'                            \
          --doc-type'[set document type]:type:->type'                                    \
          --title'[set talk title]'                                                      \
          --author'[set author name]'                                                    \
          --email'[set email]'                                                           \
          --latex-class'[set LaTeX class name]:class:->class'                            \
          --latex-class-options'[set LaTeX class options]:class-options:->class-options' \
          --base-directory'[directory to put document]'                                  \
          '*: :->args' && ret=0
      case $state in
          (type)
              local types; types=('talk' 'article' 'note')
              _describe -t 'types' 'type' types && ret=0
              ;;
          (class)
              local classes; classes=('beamer')
              _describe -t 'classes' 'class' classes && ret=0
              ;;
          (class-options)
              local class_options; class_options=(
                  'snemo' 'cpp_teaching' 'ddpfo'
                  'nologo' 'notitlelogo' 'noheaderlogo'
              )
              _describe -t 'class-options' 'option' class_options && ret=0
              ;;
          (args)
              local dirname; dirname=($(date +%y%m%d)_)
              _describe -t 'dirname' 'dirname' dirname && ret=0
              ;;
      esac
  }
#+END_SRC

** Parse C++ program options
This function parse the content of a C++ program and extract command line
options passed with [[http://www.boost.org/doc/libs/1_55_0/doc/html/program_options.html][boost::program_options]]

#+BEGIN_SRC sh
  function parse_cpp_program_options ()
  {
      __pkgtools__at_function_enter parse_cpp_program_options

      # Internal function to stream 'echo' command
      __parse ()
      {
          local find_begin_description=0
          local find_end_description=1
          local data_type=""
          for token in $(sed -n '/add_options/,/;/p' $1)
          do
              if [[ "$token" == *';'* ]]; then
                  break
              fi
              token=${token/\\n/ }
              pkgtools__msg_devel "token = ${token}"
              if [[ "$token" == *'"'* ]]; then
                  # Get option indentificator
                  if [[ "$token" == *'("'* ]]; then
                      if [[ "$token" == *'")'* ]]; then
                          continue
                      fi
                      if [ ${find_end_description} -eq 0 ]; then
                          data_type=""
                          find_end_description=1
                          find_begin_description=0
                          echo "]' \\"

                      fi
                      local tmp=$(echo ${token%?} | sed 's/[("\]//g')
                      local opt1=$(echo $tmp | cut -d',' -f1)
                      local opt2=$(echo $tmp | cut -d',' -f2)
                      if [ ${#opt1} = ${#opt2} ]; then
                          test ${#opt1} -gt 1 && echo -ne "--${opt1}"
                      elif [ ${#opt1} -gt ${#opt2} ]; then
                          echo -ne "{-${opt2},--${opt1}}"
                      else
                          echo -ne "{-${opt1},--${opt2}}"
                      fi
                  elif [[ "$token" == *'")'* ]]; then
                      token=$(echo ${token} | sed 's/[."]//g')
                      if [ ${find_begin_description} -eq 1 ]; then
                          data_type=""
                          find_end_description=1
                          find_begin_description=0
                          echo "${token%)}${data_type}]' \\"
                      fi
                  else
                      token=$(echo ${token} | sed 's/["\\]//g')
                      if [ ${find_end_description} -eq 1 ]; then
                          find_end_description=0
                          find_begin_description=1
                          echo -ne "'[${token#\"} "
                      else
                          echo -ne "${token} "
                      fi
                  fi
              elif [[ "$token" != *'->'* ]]; then
                  if [[ ${find_begin_description} -eq 1 && ${find_end_description} -eq 0 ]]; then
                      if [ "$token" != ")" ]; then
                          token=$(echo ${token} | sed 's/[;"\\]//g')
                          echo -ne "${token} "
                      fi
                      # elif [[ "${token}" == *"::value<"* ]]; then
                      #     tmp=${token##*value<}
                      #     tmp=${tmp%%>*}
                      #     if [ "${tmp}" == "bool" ];then
                      #         data_type=":boolean:(true false)"
                      #     elif [ "${tmp}" == "int" ]; then
                      #         data_type=":number"
                      #     elif [ "${tmp}" == "double" ]; then
                      #         data_type=":number"
                      #     fi
                  fi
              fi
          done
          if [ ${find_end_description} -eq 0 ]; then
              echo "]' \\"
          fi
          unset token
          unset find_begin_description find_end_description
          unset data_type
      }

      for program_file in $1
      do
          local program_name=$(basename ${program_file%.cxx})

          local completion_file=/tmp/_${program_name}
          cat ${program_file} | grep -q add_options
          if [ $? -ne 0 ]; then
              pkgtools__msg_warning "Program ${program_name} does not use boost::program_option ! Skip it !"
              continue
          else
              pkgtools__msg_notice "Build completion system for program ${program_name}"
          fi

          __header () {
              echo "#compdef ${program_name}"
              echo
              echo "function _${program_name} ()"
              echo "{"
              echo "typeset -A opt_args"
              echo "local context state line curcontext=\"$curcontext\""
              echo
              echo " _arguments \\"
          }
          __header > ${completion_file}
          __parse ${program_file} >> ${completion_file}
          __footer () {
              echo "'*: :->args' \\"
              echo "&& ret=0"
              echo
              echo "case \$state in"
              echo "args)"
              echo "_files -/"
              echo ";;"
              echo "esac"
              echo
              echo "return ret"
              echo "}"
              echo
              echo "_${program_name} \"\$@\""
              echo
              echo "# Local Variables:"
              echo "# mode: Shell-Script"
              echo "# sh-indentation: 2"
              echo "# indent-tabs-mode: nil"
              echo "# sh-basic-offset: 2"
              echo "# End:"
          }
          __footer >> ${completion_file}
          pkgtools__msg_notice "File has been parsed in ${completion_file} file"
      done

      __pkgtools__at_function_exit
      return 0
  }
  compdef '_files -g "*.cxx"' parse_cpp_program_options
#+END_SRC
